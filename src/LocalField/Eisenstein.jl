

#export

################################################################################
#
#  Base field
#
################################################################################

base_field(K::EisensteinField) = FlintQQ

################################################################################
#
#  Order type
#
################################################################################

order_type(::EisensteinField) = NfAbsOrd{EisensteinField, nf_elem}

order_type(::Type{EisensteinField}) = NfAbsOrd{EisensteinField, nf_elem}

################################################################################
#
#  Predicates
#
################################################################################

issimple(::Type{EisensteinField}) = true

issimple(::EisensteinField) = true

################################################################################
#
#  Field constructions
#
################################################################################

@doc Markdown.doc"""
    NumberField(S::Generic.ResRing{fmpq_poly}; cached::Bool = true, check::Bool = true) -> EisensteinField, Map

 The number field $K$ isomorphic to the ring $S$ and the map from $K\to S$.
"""
function NumberField(S::Generic.ResRing{fmpq_poly}; cached::Bool = true, check::Bool = true)
  Qx = parent(modulus(S))
  K, a = NumberField(modulus(S), "_a", cached = cached, check = check)
  mp = MapFromFunc(y -> S(Qx(y)), x -> K(lift(x)), K, S)
  return K, mp
end

@doc Markdown.doc"""
    NumberField(f::fmpq_poly; cached::Bool = true, check::Bool = true)

 The number field Q[x]/f generated by f.
"""
function NumberField(f::fmpq_poly; cached::Bool = true, check::Bool = true)
  return NumberField(f, "_a", cached = cached, check = check)
end

function NumberField(f::fmpz_poly, s::Symbol; cached::Bool = true, check::Bool = true)
  Qx, x = PolynomialRing(FlintQQ, string(parent(f).S))
  return NumberField(Qx(f), String(s), cached = cached, check = check)
end

function NumberField(f::fmpz_poly, s::AbstractString; cached::Bool = true, check::Bool = true)
  Qx, x = PolynomialRing(FlintQQ, string(parent(f).S))
  return NumberField(Qx(f), s, cached = cached, check = check)
end

function NumberField(f::fmpz_poly; cached::Bool = true, check::Bool = true)
  Qx, x = PolynomialRing(FlintQQ, string(parent(f).S))
  return NumberField(Qx(f), cached = cached, check = check)
end

@doc Markdown.doc"""
    radical_extension(n::Int, gen::Integer; cached::Bool = true, check::Bool = true) -> EisensteinField, nf_elem
    radical_extension(n::Int, gen::fmpz; cached::Bool = true, check::Bool = true) -> EisensteinField, nf_elem

The number field with defining polynomial $x^n-gen$.
"""
function radical_extension(n::Int, gen::Integer; cached::Bool = true, check::Bool = true)
  return radical_extension(n, fmpz(gen), cached = cached, check = check)
end

function radical_extension(n::Int, gen::fmpz; cached::Bool = true, check::Bool = true)
  kx, x = FlintQQ["x"]
  return number_field(x^n - gen, cached = cached, check = check)
end

@doc Markdown.doc"""
    cyclotomic_field(n::Int) -> EisensteinField, nf_elem

The $n$-th cyclotomic field defined by the $n$-the cyclotomic polynomial.
"""
function cyclotomic_field(n::Int; cached::Bool = true)
  return CyclotomicField(n, "z_$n", cached = cached)
end

# TODO: Some sort of reference?
@doc Markdown.doc"""
    wildanger_field(n::Int, B::fmpz) -> EisensteinField, nf_elem

Returns the field with defining polynomial $x^n + \sum_{i=0}^{n-1} (-1)^{n-i}Bx^i$.
These fields tend to have non-trivial class groups.
"""
function wildanger_field(n::Int, B::fmpz; cached::Bool = true)
  Qx, x = PolynomialRing(FlintQQ, "x", cached = false)
  f = x^n
  for i=0:n-1
    f += (-1)^(n-i)*B*x^i
  end
  return NumberField(f, "_\$", cached = cached)
end

function wildanger_field(n::Int, B::Integer; cached::Bool = true)
  return wildanger_field(n, fmpz(B), cached = cached)
end

@doc Markdown.doc"""
    quadratic_field(d::Integer) -> EisensteinField, nf_elem
    quadratic_field(d::fmpz) -> EisensteinField, nf_elem

Returns the field with defining polynomial $x^n -d$.
"""
function quadratic_field(d::fmpz; cached::Bool = true, check::Bool = true)
  Qx, x = PolynomialRing(FlintQQ)
  if nbits(d) > 100
    a = div(d, fmpz(10)^(ndigits(d, 10) - 4))
    b = mod(abs(d), 10^4)
    s = "sqrt($a..($(nbits(d)) bits)..$b)"
  else
    s = "sqrt($d)"
  end
  q, a = number_field(x^2-d, s, cached = cached, check = check)
  set_special(q, :show => show_quad)
  return q, a
end

function show_quad(io::IO, q::EisensteinField)
  d = trail(q.pol)
  if d > 0
    print(io, "Real quadratic field by ", q.pol)
  else
    print(io, "Imaginary quadratic field by ", q.pol)
  end
end

function quadratic_field(d::Integer; cached::Bool = true, check::Bool = true)
  return quadratic_field(fmpz(d), cached = cached, check = check)
end

################################################################################
#
#  Characteristic
#
################################################################################

characteristic(::EisensteinField) = 0

################################################################################
#
#  Predicates
#
################################################################################

@doc Markdown.doc"""
    isdefining_polynomial_nice(K::EisensteinField)

Tests if the defining polynomial of $K$ is integral and monic.
"""
function isdefining_polynomial_nice(K::EisensteinField)
  return Bool(K.flag & UInt(1))
end

################################################################################
#
#  Class group
#
################################################################################

@doc Markdown.doc"""
    class_group(K::EisensteinField) -> GrpAbFinGen, Map

Shortcut for {{{class_group(maximal_order(K))}}}: returns the class
group as an abelian group and a map from this group to the set
of ideals of the maximal order.
"""
function class_group(K::EisensteinField)
  return class_group(maximal_order(K))
end

################################################################################
#
#  Basis
#
################################################################################

function basis(K::EisensteinField)
  n = degree(K)
  g = gen(K);
  d = Array{typeof(g)}(undef, n)
  b = K(1)
  for i = 1:n-1
    d[i] = b
    b *= g
  end
  d[n] = b
  return d
end
